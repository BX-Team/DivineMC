From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: dan28000 <pirkldan28@gmail.com>
Date: Thu, 12 Jun 2025 15:01:00 +0200
Subject: [PATCH] rct


diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 33b0a16ffe1037c4e2c942f09cc3e0398ef878c5..192a3411015ceccebd5e466d61e373da481cdcd7 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -72,14 +72,14 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     private final ChunkStatus[] lastChunkStatus = new ChunkStatus[4];
     private final ChunkAccess[] lastChunk = new ChunkAccess[4];
     // DivineMC start - Regionized Chunk Ticking
-    private final it.unimi.dsi.fastutil.objects.ObjectArrayList<LevelChunk> spawningChunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+    private final ObjectArrayList<LevelChunk> spawningChunks = new ObjectArrayList<>();
     private final Set<ChunkHolder> chunkHoldersToBroadcast = java.util.Collections.synchronizedSet(new ReferenceOpenHashSet<>());
     // DivineMC end - Regionized Chunk Ticking
     @Nullable
     @VisibleForDebug
     private NaturalSpawner.SpawnState lastSpawnState;
     // Paper start
-    private final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<net.minecraft.world.level.chunk.LevelChunk> fullChunks = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>();
+    private final ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<LevelChunk> fullChunks = new ca.spottedleaf.concurrentutil.map.ConcurrentLong2ReferenceChainedHashTable<>();
     public int getFullChunksCount() {
         return this.fullChunks.size();
     }
@@ -158,68 +158,101 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     // Paper end - rewrite chunk system
 
     // DivineMC start - Regionized Chunk Ticking
-    private record RegionData(List<LevelChunk> chunks, List<Entity> entities) {
+    private record RegionData(it.unimi.dsi.fastutil.longs.LongOpenHashSet chunks, List<Entity> entities) {
         public boolean isEmpty() {
             return chunks.isEmpty();
         }
     }
 
-    private static final int[] DX = {1, -1, 0, 0, 1, -1, -1, 1};
-    private static final int[] DZ = {0, 0, 1, -1, 1, 1, -1, -1};
+    private record Output(RegionData[] regions, List<Entity> entities) {}
 
-    private RegionData[] splitChunksIntoRegions(List<LevelChunk> chunks) {
-        if (chunks.isEmpty()) return new RegionData[0];
+    private Output computePlayerRegionsParallel() {
+        int tickViewDistance = level.moonrise$getViewDistanceHolder().getViewDistances().tickViewDistance();
+        List<ServerPlayer> players = new java.util.ArrayList<>(level.players);
+        int max = maxChunksForViewDistance();
 
-        int size = chunks.size();
-        it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<LevelChunk> chunkSet = new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(chunks);
+        List<it.unimi.dsi.fastutil.longs.LongOpenHashSet> playerChunkSets = players.parallelStream()
+            .map(player -> {
+                ChunkPos playerChunk = player.chunkPosition();
+                int px = playerChunk.x;
+                int pz = playerChunk.z;
+                it.unimi.dsi.fastutil.longs.LongOpenHashSet chunkKeys = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(max);
+                for (int dx = -tickViewDistance; dx <= tickViewDistance; dx++) {
+                    for (int dz = -tickViewDistance; dz <= tickViewDistance; dz++) {
+                        long key = ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkKey(px + dx, pz + dz);
+                        chunkKeys.add(key);
+                    }
+                }
+                return chunkKeys;
+            }).toList();
+
+        List<it.unimi.dsi.fastutil.longs.LongOpenHashSet> mergedRegions = new java.util.ArrayList<>();
+        boolean[] merged = new boolean[playerChunkSets.size()];
 
-        it.unimi.dsi.fastutil.objects.ObjectArrayList<RegionData> groups = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(Math.max(1, level.players.size()));
-        LevelChunk[] stack = new LevelChunk[size];
-        it.unimi.dsi.fastutil.longs.Long2IntMap chunkToRegionMap = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap(size);
+        for (int i = 0; i < playerChunkSets.size(); i++) {
+            if (merged[i]) continue;
 
-        for (LevelChunk chunk : chunks) {
-            if (!chunkSet.contains(chunk)) continue;
+            it.unimi.dsi.fastutil.longs.LongOpenHashSet region = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(playerChunkSets.get(i));
+            merged[i] = true;
 
-            it.unimi.dsi.fastutil.objects.ObjectArrayList<LevelChunk> group = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(64);
-            stack[0] = chunk;
-            int stackPointer = 1;
+            boolean madeChanges;
+            do {
+                madeChanges = false;
+                for (int j = i + 1; j < playerChunkSets.size(); j++) {
+                    if (merged[j]) continue;
 
-            while (stackPointer > 0) {
-                LevelChunk current = stack[--stackPointer];
-                group.add(current);
+                    it.unimi.dsi.fastutil.longs.LongOpenHashSet set = playerChunkSets.get(j);
+
+                    boolean hasIntersection = false;
+                    it.unimi.dsi.fastutil.longs.LongIterator iter = set.iterator();
+                    while (iter.hasNext()) {
+                        if (region.contains(iter.nextLong())) {
+                            hasIntersection = true;
+                            break;
+                        }
+                    }
 
-                for (int i = 0; i < 8; i++) {
-                    LevelChunk neighbor = getChunk(current.locX + DX[i], current.locZ + DZ[i], false);
-                    if (neighbor != null && chunkSet.remove(neighbor)) {
-                        stack[stackPointer++] = neighbor;
+                    if (hasIntersection) {
+                        region.addAll(set);
+                        merged[j] = true;
+                        madeChanges = true;
                     }
                 }
-            }
+            } while (madeChanges);
 
-            RegionData regionData = new RegionData(group, new it.unimi.dsi.fastutil.objects.ObjectArrayList<>());
-            groups.add(regionData);
-            int index = groups.indexOf(regionData);
+            mergedRegions.add(region);
+        }
 
-            for (LevelChunk regionChunk : group) {
-                chunkToRegionMap.put(regionChunk.coordinateKey, index);
+        ObjectArrayList<RegionData> regions = new ObjectArrayList<>();
+        it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap chunkToRegion = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap(max * mergedRegions.size());
+        chunkToRegion.defaultReturnValue(-1);
+        for (int i = 0; i < mergedRegions.size(); i++) {
+            regions.add(new RegionData(mergedRegions.get(i), it.unimi.dsi.fastutil.objects.ObjectLists.synchronize(new ObjectArrayList<>())));
+            for (long key : mergedRegions.get(i)) {
+                chunkToRegion.put(key, i);
             }
-
-            if (chunkSet.isEmpty()) break;
         }
 
-        level.entityTickList.entities.forEach(entity -> {
-            long chunkKey = entity.chunkPosition().longKey;
+        final it.unimi.dsi.fastutil.objects.ObjectList<Entity> firstTick = it.unimi.dsi.fastutil.objects.ObjectLists.synchronize(new it.unimi.dsi.fastutil.objects.ObjectArrayList<>());
 
-            int index = chunkToRegionMap.get(chunkKey);
-            RegionData regionData = groups.get(index);
-            if (regionData != null) {
-                regionData.entities().add(entity);
+        level.entityTickList.entities.parallelStream().forEach(entity -> {
+            long chunkKey = entity.chunkPosition().longKey;
+            int regionIndex = chunkToRegion.get(chunkKey);
+            if (regionIndex != -1) {
+                regions.get(regionIndex).entities().add(entity);
             } else {
-                tickEntity(entity);
+                firstTick.add(entity);
             }
         });
 
-        return groups.toArray(new RegionData[0]);
+        return new Output(regions.toArray(new RegionData[0]), firstTick);
+    }
+
+    // Should be max safe estimate of ticking chunks in a region
+    private int maxChunksForViewDistance() {
+        ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.ViewDistances distances = level.moonrise$getViewDistanceHolder().getViewDistances();
+        int diameter = 2 * distances.tickViewDistance() + 1;
+        return diameter * diameter;
     }
 
     private void tickEntity(Entity entity) {
@@ -244,58 +277,112 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
     // Paper start - chunk tick iteration optimisations
     private final ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom shuffleRandom = new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(0L);
+
     private void iterateTickingChunksFaster() {
         final ServerLevel world = this.level;
         final int randomTickSpeed = world.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
 
         // TODO check on update: impl of forEachBlockTickingChunk will only iterate ENTITY ticking chunks!
         // TODO check on update: consumer just runs tickChunk
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getEntityTickingChunks();
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<LevelChunk> entityTickingChunks = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getEntityTickingChunks();
 
         // note: we can use the backing array here because:
         // 1. we do not care about new additions
         // 2. _removes_ are impossible at this stage in the tick
-        final LevelChunk[] raw = entityTickingChunks.getRawDataUnchecked();
+        final LevelChunk[] raw = entityTickingChunks.toArray(new LevelChunk[0]); // DivineMC - use toArray instead of getRawDataUnchecked this way is safe and doesn't have performance impact
         final int size = entityTickingChunks.size();
 
         // DivineMC start - Regionized Chunk Ticking
         if (org.bxteam.divinemc.config.DivineConfig.AsyncCategory.enableRegionizedChunkTicking) {
-            List<LevelChunk> chunks = new java.util.ArrayList<>(size);
-            for (int i = 0; i < size; ++i) {
-                chunks.add(raw[i]);
-            }
-
-            final RegionData[] regions = splitChunksIntoRegions(chunks);
+            final Output output = computePlayerRegionsParallel();
+            final RegionData[] regions = output.regions();
             int regionCount = regions.length;
 
             java.util.concurrent.CountDownLatch latch = new java.util.concurrent.CountDownLatch(regionCount);
-
+            regionAmount.add(regionCount);
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(level); // Paper - EAR
+
+            debug(world.uuid);
+
             try {
                 java.util.concurrent.ForkJoinPool.managedBlock(new java.util.concurrent.ForkJoinPool.ManagedBlocker() {
                     @Override
                     public boolean block() throws InterruptedException {
+                        // Inside the managed block where regions are processed:
+                        ObjectArrayList<java.util.concurrent.CompletableFuture<it.unimi.dsi.fastutil.longs.LongOpenHashSet>> ticked = new ObjectArrayList<>(regionCount);
                         for (final RegionData region : regions) {
                             if (region == null || region.isEmpty()) {
                                 latch.countDown();
                                 continue;
                             }
 
-                            REGION_EXECUTOR.execute(() -> {
+                            chunksPerRegion.add(region.chunks.size());
+                            entityPerRegion.add(region.entities.size());
+
+                            ticked.add(java.util.concurrent.CompletableFuture.supplyAsync(() -> {
+                                // Flood fill: resolve chunk keys to LevelChunk
+                                it.unimi.dsi.fastutil.objects.ObjectArrayList<net.minecraft.world.level.chunk.LevelChunk> regionChunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(region.chunks().size());
+                                it.unimi.dsi.fastutil.longs.LongOpenHashSet regionChunksIDs = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(region.chunks().size());
+                                for (long key : region.chunks()) {
+                                    net.minecraft.world.level.chunk.LevelChunk chunk = fullChunks.get(key);
+                                    if (chunk != null) {
+                                        regionChunks.add(chunk);
+                                        regionChunksIDs.add(key);
+                                    }
+                                }
+
                                 try {
-                                    for (LevelChunk chunk : region.chunks()) {
+                                    for (net.minecraft.world.level.chunk.LevelChunk chunk : regionChunks) {
                                         world.tickChunk(chunk, randomTickSpeed);
                                     }
-
-                                    for (Entity entity : region.entities()) {
+                                    for (net.minecraft.world.entity.Entity entity : region.entities()) {
                                         tickEntity(entity);
                                     }
                                 } finally {
                                     latch.countDown();
                                 }
-                            });
+                                return regionChunksIDs;
+                            }, REGION_EXECUTOR));
                         }
 
+                        CompletableFuture.runAsync(() -> {
+                            CompletableFuture<Void> allRegionsDone = CompletableFuture.allOf(ticked.toArray(new CompletableFuture[0]));
+                            try {
+                                allRegionsDone.join();
+                            } catch (java.util.concurrent.CompletionException ex) {
+                                LOGGER.error("Error during region chunk ticking", ex.getCause());
+                            }
+
+                            // Collect all ticked chunk keys from regionChunks returned by futures
+                            it.unimi.dsi.fastutil.longs.LongOpenHashSet tickedChunkKeys = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(raw.length);
+
+                            for (CompletableFuture<it.unimi.dsi.fastutil.longs.LongOpenHashSet> future : ticked) {
+                                if (!future.isCompletedExceptionally()) {
+                                    try {
+                                        it.unimi.dsi.fastutil.longs.LongOpenHashSet regionChunks = future.join();
+                                        tickedChunkKeys.addAll(regionChunks);
+                                    } catch (Exception e) {
+                                        LOGGER.error("Exception in region ticking future", e);
+                                    }
+                                }
+                            }
+
+                            if (loopCount >= anInt) {
+                                LOGGER.info("total chunks ticked: {}", tickedChunkKeys.size());
+                            }
+
+                            int i = 0;
+                            for (LevelChunk chunk : raw) {
+                                if (!tickedChunkKeys.contains(chunk.coordinateKey)) {
+                                    world.tickChunk(chunk, randomTickSpeed);
+                                    i++;
+                                }
+                            }
+                            missingChunksList.add(i);
+
+                            output.entities.forEach(ServerChunkCache.this::tickEntity);
+                        }, REGION_EXECUTOR).join();
+
                         latch.await();
                         return true;
                     }
@@ -324,6 +411,34 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     }
     // Paper end - chunk tick iteration optimisations
 
+    // debug start
+    private final int anInt = 300;
+    private final it.unimi.dsi.fastutil.ints.IntArrayList chunksPerRegion = new it.unimi.dsi.fastutil.ints.IntArrayList(anInt);
+    private final it.unimi.dsi.fastutil.ints.IntArrayList regionAmount = new it.unimi.dsi.fastutil.ints.IntArrayList(anInt);
+    private final it.unimi.dsi.fastutil.ints.IntArrayList entityPerRegion = new it.unimi.dsi.fastutil.ints.IntArrayList(anInt);
+    private final it.unimi.dsi.fastutil.ints.IntArrayList missingChunksList = new it.unimi.dsi.fastutil.ints.IntArrayList(anInt);
+    private final String[] messages = new String[]{
+        "Average chunk count per region: ",
+        "average region count: ",
+        "average entity count per region: ",
+        "average missing chunk count: ",
+    };
+    private int loopCount = 0;
+    private void debug(java.util.UUID uuid) {
+        if (loopCount++ > anInt) {
+            StringBuilder sb = new StringBuilder();
+            sb.append(org.bukkit.Bukkit.getWorld(uuid).getName()).append('\n');
+            java.util.concurrent.atomic.AtomicInteger atomicInteger = new java.util.concurrent.atomic.AtomicInteger(0);
+            java.util.stream.Stream.of(chunksPerRegion, regionAmount, entityPerRegion, missingChunksList).forEach(list -> {
+                list.intStream().average().ifPresent(avg -> sb.append(messages[atomicInteger.getAndIncrement()]).append(avg).append('\n'));
+                list.clear();
+            });
+            LOGGER.info(sb.toString());
+            loopCount = 0;
+        }
+    }
+    // debug end
+
     // DivineMC start - Async mob spawning
     public boolean firstRunSpawnCounts = true;
     public final java.util.concurrent.atomic.AtomicBoolean spawnCountsReady = new java.util.concurrent.atomic.AtomicBoolean(false);
@@ -644,14 +759,19 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
         long gameTime = this.level.getGameTime();
         long l = gameTime - this.lastInhabitedUpdate;
         this.lastInhabitedUpdate = gameTime;
-        if (!this.level.isDebug()) {
-            if (this.level.tickRateManager().runsNormally()) {
-                this.tickChunks(l);
-            }
 
+        if (this.level.isDebug()) { // DivineMC - we don't care about debug worlds
+            return;
+        }
+
+        if (!this.level.tickRateManager().runsNormally()) { // DivineMC - when frozen only broadcast changed chunks and don't run async mob spawning
             this.broadcastChangedChunks();
+            return;
         }
 
+        this.tickChunks(l);
+        this.broadcastChangedChunks();
+
         // DivineMC start - Async mob spawning
         if (org.bxteam.divinemc.config.DivineConfig.AsyncCategory.enableAsyncSpawning) {
             for (ServerPlayer player : this.level.players) {
